//
//  BFCacheSnapshotManager.swift
//  üì∏ **Ïö∞ÏÑ†ÏàúÏúÑ Í∏∞Î∞ò BFCache Î≥µÏõê ÏãúÏä§ÌÖú**
//  üéØ 1ÏàúÏúÑ: ÏöîÏÜå id/URL Ìï¥Ïãú
//  üéØ 2ÏàúÏúÑ: ÏïàÏ†ïÏ†Å ÏÜçÏÑ± Í∏∞Î∞ò CSS
//  üéØ 3ÏàúÏúÑ: Íµ¨Ï°∞+Ïó≠Ìï† Î≥¥Í∞ï CSS
//  üéØ 4ÏàúÏúÑ: Î°úÎî© Ìä∏Î¶¨Í±∞ ÌõÑ Ïû¨ÌÉêÏÉâ
//  üéØ 5ÏàúÏúÑ: ÏÉÅÎåÄÏ¢åÌëú ÌíÄÎ∞±
//  ‚ö° ÎπÑÎèôÍ∏∞ Ï≤òÎ¶¨ + Î†åÎçîÎßÅ ÏïàÏ†ï ÎåÄÍ∏∞
//  üîí ÌÉÄÏûÖ ÏïàÏ†ÑÏÑ±: Swift Ìò∏Ìôò Í∏∞Î≥∏ ÌÉÄÏûÖÎßå ÏÇ¨Ïö©
//  üì® MessageHandler Î∞©ÏãùÏúºÎ°ú ÎπÑÎèôÍ∏∞ Í≤∞Í≥º ÏàòÏã†
//

import UIKit
import WebKit
import SwiftUI

// MARK: - üì∏ **Îã®ÏàúÌôîÎêú BFCache ÌéòÏù¥ÏßÄ Ïä§ÎÉÖÏÉ∑**
struct BFCacheSnapshot: Codable {
    let pageRecord: PageRecord
    var domSnapshot: String?
    let scrollPosition: CGPoint
    let scrollPositionPercent: CGPoint
    let contentSize: CGSize
    let viewportSize: CGSize
    let actualScrollableSize: CGSize
    var jsState: [String: Any]?
    let timestamp: Date
    var webViewSnapshotPath: String?
    let captureStatus: CaptureStatus
    let version: Int
    
    enum CaptureStatus: String, Codable {
        case complete
        case partial
        case visualOnly
        case failed
    }
    
    // CodableÏùÑ ÏúÑÌïú CodingKeys
    enum CodingKeys: String, CodingKey {
        case pageRecord
        case domSnapshot
        case scrollPosition
        case scrollPositionPercent
        case contentSize
        case viewportSize
        case actualScrollableSize
        case jsState
        case timestamp
        case webViewSnapshotPath
        case captureStatus
        case version
    }
    
    // Custom encoding/decoding for [String: Any]
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        pageRecord = try container.decode(PageRecord.self, forKey: .pageRecord)
        domSnapshot = try container.decodeIfPresent(String.self, forKey: .domSnapshot)
        scrollPosition = try container.decode(CGPoint.self, forKey: .scrollPosition)
        scrollPositionPercent = try container.decodeIfPresent(CGPoint.self, forKey: .scrollPositionPercent) ?? CGPoint.zero
        contentSize = try container.decodeIfPresent(CGSize.self, forKey: .contentSize) ?? CGSize.zero
        viewportSize = try container.decodeIfPresent(CGSize.self, forKey: .viewportSize) ?? CGSize.zero
        actualScrollableSize = try container.decodeIfPresent(CGSize.self, forKey: .actualScrollableSize) ?? CGSize.zero
        
        // JSON decode for [String: Any]
        if let jsData = try container.decodeIfPresent(Data.self, forKey: .jsState) {
            jsState = try JSONSerialization.jsonObject(with: jsData) as? [String: Any]
        }
        
        timestamp = try container.decode(Date.self, forKey: .timestamp)
        webViewSnapshotPath = try container.decodeIfPresent(String.self, forKey: .webViewSnapshotPath)
        captureStatus = try container.decode(CaptureStatus.self, forKey: .captureStatus)
        version = try container.decode(Int.self, forKey: .version)
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(pageRecord, forKey: .pageRecord)
        try container.encodeIfPresent(domSnapshot, forKey: .domSnapshot)
        try container.encode(scrollPosition, forKey: .scrollPosition)
        try container.encode(scrollPositionPercent, forKey: .scrollPositionPercent)
        try container.encode(contentSize, forKey: .contentSize)
        try container.encode(viewportSize, forKey: .viewportSize)
        try container.encode(actualScrollableSize, forKey: .actualScrollableSize)
        
        // JSON encode for [String: Any]
        if let js = jsState {
            let jsData = try JSONSerialization.data(withJSONObject: js)
            try container.encode(jsData, forKey: .jsState)
        }
        
        try container.encode(timestamp, forKey: .timestamp)
        try container.encodeIfPresent(webViewSnapshotPath, forKey: .webViewSnapshotPath)
        try container.encode(captureStatus, forKey: .captureStatus)
        try container.encode(version, forKey: .version)
    }
    
    // ÏßÅÏ†ë Ï¥àÍ∏∞ÌôîÏö© init
    init(pageRecord: PageRecord, 
         domSnapshot: String? = nil, 
         scrollPosition: CGPoint, 
         scrollPositionPercent: CGPoint = CGPoint.zero,
         contentSize: CGSize = CGSize.zero,
         viewportSize: CGSize = CGSize.zero,
         actualScrollableSize: CGSize = CGSize.zero,
         jsState: [String: Any]? = nil, 
         timestamp: Date, 
         webViewSnapshotPath: String? = nil, 
         captureStatus: CaptureStatus = .partial, 
         version: Int = 1) {
        self.pageRecord = pageRecord
        self.domSnapshot = domSnapshot
        self.scrollPosition = scrollPosition
        self.scrollPositionPercent = scrollPositionPercent
        self.contentSize = contentSize
        self.viewportSize = viewportSize
        self.actualScrollableSize = actualScrollableSize
        self.jsState = jsState
        self.timestamp = timestamp
        self.webViewSnapshotPath = webViewSnapshotPath
        self.captureStatus = captureStatus
        self.version = version
    }
    
    // Ïù¥ÎØ∏ÏßÄ Î°úÎìú Î©îÏÑúÎìú
    func loadImage() -> UIImage? {
        guard let path = webViewSnapshotPath else { return nil }
        let url = URL(fileURLWithPath: path)
        guard FileManager.default.fileExists(atPath: url.path) else { return nil }
        return UIImage(contentsOfFile: url.path)
    }
    
    // MARK: - üéØ **MessageHandler Í∏∞Î∞ò Î≥µÏõê ÏãúÏä§ÌÖú**
    
    func restore(to webView: WKWebView, completion: @escaping (Bool) -> Void) {
        TabPersistenceManager.debugMessages.append("üéØ Ïö∞ÏÑ†ÏàúÏúÑ Í∏∞Î∞ò BFCache Î≥µÏõê ÏãúÏûë")
        TabPersistenceManager.debugMessages.append("üìä Î≥µÏõê ÎåÄÏÉÅ: \(pageRecord.url.host ?? "unknown") - \(pageRecord.title)")
        TabPersistenceManager.debugMessages.append("üìä Î™©Ìëú ÏúÑÏπò: X=\(String(format: "%.1f", scrollPosition.x))px, Y=\(String(format: "%.1f", scrollPosition.y))px")
        TabPersistenceManager.debugMessages.append("üìä Î™©Ìëú Î∞±Î∂ÑÏú®: X=\(String(format: "%.2f", scrollPositionPercent.x))%, Y=\(String(format: "%.2f", scrollPositionPercent.y))%")
        
        var didFinish = false
        var timeoutWorkItem: DispatchWorkItem?

        let finish: (Bool) -> Void = { [weak webView] success in
            guard !didFinish else { return }
            didFinish = true
            timeoutWorkItem?.cancel()
            timeoutWorkItem = nil
            if let webView = webView {
                webView.configuration.userContentController.removeScriptMessageHandler(forName: "bfcacheRestoreResult")
            }
            completion(success)
        }

        // MessageHandler Îì±Î°ù (ÏûÑÏãú)
        let messageHandler = BFCacheRestoreMessageHandler { result in
            // Í≤∞Í≥º Ï≤òÎ¶¨
            let success = (result["success"] as? Bool) ?? false
            
            if let method = result["method"] as? String {
                TabPersistenceManager.debugMessages.append("‚úÖ Î≥µÏõê Î∞©Î≤ï: \(method)")
            }
            
            if let finalPosition = result["finalPosition"] as? [String: Double] {
                TabPersistenceManager.debugMessages.append("üìç ÏµúÏ¢Ö ÏúÑÏπò: X=\(String(format: "%.1f", finalPosition["x"] ?? 0))px, Y=\(String(format: "%.1f", finalPosition["y"] ?? 0))px")
            }
            
            if let difference = result["difference"] as? [String: Double] {
                TabPersistenceManager.debugMessages.append("üìè ÏúÑÏπò Ï∞®Ïù¥: X=\(String(format: "%.1f", difference["x"] ?? 0))px, Y=\(String(format: "%.1f", difference["y"] ?? 0))px")
            }
            
            if let logs = result["logs"] as? [String] {
                for log in logs.prefix(10) {
                    TabPersistenceManager.debugMessages.append("   \(log)")
                }
            }
            
            TabPersistenceManager.debugMessages.append("üéØ BFCache Î≥µÏõê ÏôÑÎ£å: \(success ? "ÏÑ±Í≥µ" : "Ïã§Ìå®")")
            
            finish(success)
        }
        
        webView.configuration.userContentController.add(messageHandler, name: "bfcacheRestoreResult")
        
        // ÌÉÄÏûÑÏïÑÏõÉ ÏÑ§Ï†ï (5Ï¥à)
        let timeoutItem = DispatchWorkItem {
            TabPersistenceManager.debugMessages.append("‚è∞ Î≥µÏõê ÌÉÄÏûÑÏïÑÏõÉ (5Ï¥à Ï¥àÍ≥º)")
            finish(false)
        }
        timeoutWorkItem = timeoutItem
        DispatchQueue.main.asyncAfter(deadline: .now() + 5.0, execute: timeoutItem)
        
        // JavaScript Ïä§ÌÅ¨Î¶ΩÌä∏ Ïã§Ìñâ
        let js = generatePriorityBasedRestoreScript()
        
        webView.evaluateJavaScript(js) { result, error in
            if let error = error {
                TabPersistenceManager.debugMessages.append("‚ùå Î≥µÏõê Ïä§ÌÅ¨Î¶ΩÌä∏ Ïã§Ìñâ Ïã§Ìå®: \(error.localizedDescription)")
                finish(false)
            } else {
                TabPersistenceManager.debugMessages.append("‚úÖ Î≥µÏõê Ïä§ÌÅ¨Î¶ΩÌä∏ Ïã§Ìñâ ÏÑ±Í≥µ")
            }
        }

    // MARK: - üéØ **MessageHandler Í∏∞Î∞ò Î≥µÏõê Ïä§ÌÅ¨Î¶ΩÌä∏ ÏÉùÏÑ±**
    
    private func generatePriorityBasedRestoreScript() -> String {
        let targetX = scrollPosition.x
        let targetY = scrollPosition.y
        let targetPercentX = scrollPositionPercent.x
        let targetPercentY = scrollPositionPercent.y
        let urlFragment = pageRecord.url.fragment ?? ""
        
        // jsStateÏóêÏÑú ÏïµÏª§ Ï†ïÎ≥¥ Ï∂îÏ∂ú
        var anchorDataJSON = "null"
        if let jsState = self.jsState,
           let infiniteScrollAnchorData = jsState["infiniteScrollAnchors"] as? [String: Any],
           let dataJSON = convertToJSONString(infiniteScrollAnchorData) {
            anchorDataJSON = dataJSON
        }
        
        return """
        (function() {
            (async function() {
                try {
                const logs = [];
                const targetX = parseFloat('\(targetX)');
                const targetY = parseFloat('\(targetY)');
                const targetPercentX = parseFloat('\(targetPercentX)');
                const targetPercentY = parseFloat('\(targetPercentY)');
                const urlFragment = '\(urlFragment)';
                const anchorData = \(anchorDataJSON);
                
                logs.push('üéØ Ïö∞ÏÑ†ÏàúÏúÑ Í∏∞Î∞ò Î≥µÏõê ÏãúÏûë');
                logs.push('Î™©Ìëú: X=' + targetX.toFixed(1) + 'px, Y=' + targetY.toFixed(1) + 'px');
                logs.push('Î∞±Î∂ÑÏú®: X=' + targetPercentX.toFixed(2) + '%, Y=' + targetPercentY.toFixed(2) + '%');
                
                // üéØ **Í≥µÌÜµ Ïú†Ìã∏Î¶¨Ìã∞**
                function getROOT() { 
                    return document.scrollingElement || document.documentElement; 
                }
                
                function getMaxScroll() { 
                    const r = getROOT(); 
                    return { 
                        x: Math.max(0, r.scrollWidth - window.innerWidth),
                        y: Math.max(0, r.scrollHeight - window.innerHeight) 
                    }; 
                }
                
                // üéØ **Î†åÎçîÎßÅ ÏïàÏ†ï ÎåÄÍ∏∞ (ÎπÑÎèôÍ∏∞)**
                async function waitForStableLayout(options = {}) {
                    const { frames = 6, timeout = 2000, threshold = 2 } = options;
                    const ROOT = getROOT();
                    
                    return new Promise((resolve) => {
                        let last = ROOT.scrollHeight;
                        let stable = 0;
                        let rafCount = 0;
                        const maxRaf = Math.ceil(timeout / 16);
                        
                        const checkStability = () => {
                            const h = ROOT.scrollHeight;
                            if (Math.abs(h - last) <= threshold) {
                                stable++;
                            } else {
                                stable = 0;
                            }
                            last = h;
                            
                            rafCount++;
                            
                            if (stable >= frames || rafCount >= maxRaf) {
                                resolve(stable >= frames);
                            } else {
                                requestAnimationFrame(checkStability);
                            }
                        };
                        
                        requestAnimationFrame(checkStability);
                    });
                }
                
                // üéØ **MutationObserver + ResizeObserver ÏïàÏ†ï ÎåÄÍ∏∞**
                async function waitForDOMStable(options = {}) {
                    const { timeout = 1000, stableTime = 300 } = options;
                    
                    return new Promise((resolve) => {
                        let timer = null;
                        let timeoutTimer = null;
                        
                        const cleanup = () => {
                            if (timer) clearTimeout(timer);
                            if (timeoutTimer) clearTimeout(timeoutTimer);
                            if (mutationObs) mutationObs.disconnect();
                            if (resizeObs) resizeObs.disconnect();
                        };
                        
                        const markStable = () => {
                            cleanup();
                            resolve(true);
                        };
                        
                        const resetTimer = () => {
                            if (timer) clearTimeout(timer);
                            timer = setTimeout(markStable, stableTime);
                        };
                        
                        const ROOT = getROOT();
                        
                        const mutationObs = new MutationObserver(resetTimer);
                        mutationObs.observe(ROOT, { 
                            childList: true, 
                            subtree: true,
                            attributes: false,
                            characterData: false 
                        });
                        
                        const resizeObs = new ResizeObserver(resetTimer);
                        resizeObs.observe(ROOT);
                        
                        resetTimer();
                        
                        timeoutTimer = setTimeout(() => {
                            cleanup();
                            resolve(false);
                        }, timeout);
                    });
                }
                
                // üéØ **Ï†ïÎ∞Ä Ïä§ÌÅ¨Î°§ Ìï®Ïàò**
                function preciseScrollTo(x, y) {
                    const ROOT = getROOT();
                    
                    // scroll-behavior Í∞ïÏ†ú ÎπÑÌôúÏÑ±Ìôî
                    const originalBehavior = ROOT.style.scrollBehavior;
                    ROOT.style.scrollBehavior = 'auto';
                    document.documentElement.style.scrollBehavior = 'auto';
                    document.body.style.scrollBehavior = 'auto';
                    
                    // Í≥†Ï†ï Ìó§Îçî ÎÜíÏù¥ Î≥¥Ï†ï
                    const headerHeight = fixedHeaderHeight();
                    const adjustedY = Math.max(0, y - headerHeight);
                    
                    ROOT.scrollLeft = x;
                    ROOT.scrollTop = adjustedY;
                    
                    // ÏõêÎûò ÏÉÅÌÉúÎ°ú Î≥µÏõê
                    if (originalBehavior) {
                        ROOT.style.scrollBehavior = originalBehavior;
                    }
                    
                    return { 
                        x: ROOT.scrollLeft || 0, 
                        y: ROOT.scrollTop || 0,
                        headerAdjustment: headerHeight
                    };
                }
                
                function fixedHeaderHeight() {
                    const cands = document.querySelectorAll('header, [class*="header"], [class*="gnb"], [class*="navbar"], [class*="nav-bar"]');
                    let h = 0;
                    cands.forEach(el => {
                        const cs = getComputedStyle(el);
                        if (cs.position === 'fixed' || cs.position === 'sticky') {
                            h = Math.max(h, el.getBoundingClientRect().height);
                        }
                    });
                    return h;
                }
                
                // üéØ **1ÏàúÏúÑ: ÏöîÏÜå id/URL Ìï¥Ïãú**
                async function tryPriority1_IdHash() {
                    logs.push('üéØ [1ÏàúÏúÑ] ÏöîÏÜå id/URL Ìï¥Ïãú ÏãúÎèÑ');
                    
                    if (urlFragment) {
                        logs.push('URL Fragment: #' + urlFragment);
                        
                        // idÎ°ú Ï∞æÍ∏∞
                        let targetElement = document.getElementById(urlFragment);
                        
                        // data-anchorÎ°ú Ï∞æÍ∏∞
                        if (!targetElement) {
                            targetElement = document.querySelector('[data-anchor="' + urlFragment + '"]');
                        }
                        
                        if (targetElement) {
                            const ROOT = getROOT();
                            const rect = targetElement.getBoundingClientRect();
                            const absoluteY = ROOT.scrollTop + rect.top;
                            
                            const result = preciseScrollTo(0, absoluteY);
                            logs.push('‚úÖ [1ÏàúÏúÑ] ÏÑ±Í≥µ: id/Ìï¥ÏãúÎ°ú ÏöîÏÜå Ï∞æÏùå');
                            logs.push('ÏöîÏÜå ÏúÑÏπò: Y=' + absoluteY.toFixed(1) + 'px');
                            
                            return {
                                success: true,
                                method: 'priority1_id_hash',
                                element: targetElement.tagName + (targetElement.id ? '#' + targetElement.id : ''),
                                result: result
                            };
                        }
                        
                        logs.push('‚ùå [1ÏàúÏúÑ] Ïã§Ìå®: id/Ìï¥Ïãú ÏöîÏÜå ÏóÜÏùå');
                    } else {
                        logs.push('‚è≠Ô∏è [1ÏàúÏúÑ] Ïä§ÌÇµ: URL Fragment ÏóÜÏùå');
                    }
                    
                    return { success: false };
                }
                
                // üéØ **2ÏàúÏúÑ: ÏïàÏ†ïÏ†Å ÏÜçÏÑ± Í∏∞Î∞ò CSS**
                async function tryPriority2_StableAttributes() {
                    logs.push('üéØ [2ÏàúÏúÑ] ÏïàÏ†ïÏ†Å ÏÜçÏÑ± Í∏∞Î∞ò CSS ÏãúÎèÑ');
                    
                    if (!anchorData || !anchorData.anchors || anchorData.anchors.length === 0) {
                        logs.push('‚è≠Ô∏è [2ÏàúÏúÑ] Ïä§ÌÇµ: ÏïµÏª§ Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå');
                        return { success: false };
                    }
                    
                    const anchors = anchorData.anchors;
                    logs.push('ÏïµÏª§ Îç∞Ïù¥ÌÑ∞: ' + anchors.length + 'Í∞ú');
                    
                    // ÏïàÏ†ïÏ†Å ÏÜçÏÑ±ÏùÑ Í∞ÄÏßÑ ÏïµÏª§ Ïö∞ÏÑ† ÌÉêÏÉâ
                    for (let i = 0; i < anchors.length; i++) {
                        const anchor = anchors[i];
                        let targetElement = null;
                        let matchMethod = '';
                        
                        // data-idÎ°ú Ï∞æÍ∏∞
                        if (anchor.element && anchor.element.dataset && anchor.element.dataset.id) {
                            targetElement = document.querySelector('[data-id="' + anchor.element.dataset.id + '"]');
                            matchMethod = 'data-id';
                        }
                        
                        // data-anchorÎ°ú Ï∞æÍ∏∞
                        if (!targetElement && anchor.element && anchor.element.dataset && anchor.element.dataset.anchor) {
                            targetElement = document.querySelector('[data-anchor="' + anchor.element.dataset.anchor + '"]');
                            matchMethod = 'data-anchor';
                        }
                        
                        // data-test-idÎ°ú Ï∞æÍ∏∞
                        if (!targetElement && anchor.element && anchor.element.dataset && anchor.element.dataset.testId) {
                            targetElement = document.querySelector('[data-test-id="' + anchor.element.dataset.testId + '"]');
                            matchMethod = 'data-test-id';
                        }
                        
                        // itemidÎ°ú Ï∞æÍ∏∞
                        if (!targetElement && anchor.element && anchor.element.itemId) {
                            targetElement = document.querySelector('[itemid="' + anchor.element.itemId + '"]');
                            matchMethod = 'itemid';
                        }
                        
                        if (targetElement) {
                            const ROOT = getROOT();
                            const rect = targetElement.getBoundingClientRect();
                            const absoluteY = ROOT.scrollTop + rect.top;
                            
                            const result = preciseScrollTo(0, absoluteY);
                            logs.push('‚úÖ [2ÏàúÏúÑ] ÏÑ±Í≥µ: ' + matchMethod + 'Î°ú ÏöîÏÜå Ï∞æÏùå');
                            
                            return {
                                success: true,
                                method: 'priority2_stable_attr_' + matchMethod,
                                result: result
                            };
                        }
                    }
                    
                    logs.push('‚ùå [2ÏàúÏúÑ] Ïã§Ìå®: ÏïàÏ†ïÏ†Å ÏÜçÏÑ± Îß§Ïπ≠ ÏóÜÏùå');
                    return { success: false };
                }
                
                // üéØ **3ÏàúÏúÑ: Íµ¨Ï°∞+Ïó≠Ìï† Î≥¥Í∞ï CSS**
                async function tryPriority3_StructuralRole() {
                    logs.push('üéØ [3ÏàúÏúÑ] Íµ¨Ï°∞+Ïó≠Ìï† Î≥¥Í∞ï CSS ÏãúÎèÑ');
                    
                    if (!anchorData || !anchorData.anchors || anchorData.anchors.length === 0) {
                        logs.push('‚è≠Ô∏è [3ÏàúÏúÑ] Ïä§ÌÇµ: ÏïµÏª§ Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå');
                        return { success: false };
                    }
                    
                    const anchors = anchorData.anchors;
                    
                    // role, ARIA ÏÜçÏÑ±ÏùÑ Í∞ÄÏßÑ ÏïµÏª§ ÌÉêÏÉâ
                    for (let i = 0; i < anchors.length; i++) {
                        const anchor = anchors[i];
                        let targetElement = null;
                        let matchMethod = '';
                        
                        // roleÎ°ú Ï∞æÍ∏∞
                        if (anchor.element && anchor.element.role) {
                            const roleElements = document.querySelectorAll('[role="' + anchor.element.role + '"]');
                            if (roleElements.length > 0) {
                                // ÌÖçÏä§Ìä∏ ÎÇ¥Ïö©ÏúºÎ°ú Ï∂îÍ∞Ä Îß§Ïπ≠
                                for (let j = 0; j < roleElements.length; j++) {
                                    const elem = roleElements[j];
                                    if (anchor.textContent && elem.textContent && 
                                        elem.textContent.includes(anchor.textContent.substring(0, 50))) {
                                        targetElement = elem;
                                        matchMethod = 'role_with_text';
                                        break;
                                    }
                                }
                                if (!targetElement) {
                                    targetElement = roleElements[0];
                                    matchMethod = 'role';
                                }
                            }
                        }
                        
                        // aria-labelledbyÎ°ú Ï∞æÍ∏∞
                        if (!targetElement && anchor.element && anchor.element.ariaLabelledBy) {
                            targetElement = document.querySelector('[aria-labelledby="' + anchor.element.ariaLabelledBy + '"]');
                            matchMethod = 'aria-labelledby';
                        }
                        
                        if (targetElement) {
                            const ROOT = getROOT();
                            const rect = targetElement.getBoundingClientRect();
                            const absoluteY = ROOT.scrollTop + rect.top;
                            
                            const result = preciseScrollTo(0, absoluteY);
                            logs.push('‚úÖ [3ÏàúÏúÑ] ÏÑ±Í≥µ: ' + matchMethod + 'Î°ú ÏöîÏÜå Ï∞æÏùå');
                            
                            return {
                                success: true,
                                method: 'priority3_structural_' + matchMethod,
                                result: result
                            };
                        }
                    }
                    
                    logs.push('‚ùå [3ÏàúÏúÑ] Ïã§Ìå®: Íµ¨Ï°∞+Ïó≠Ìï† Îß§Ïπ≠ ÏóÜÏùå');
                    return { success: false };
                }
                
                // üéØ **4ÏàúÏúÑ: Î°úÎî© Ìä∏Î¶¨Í±∞ ÌõÑ Ïû¨ÌÉêÏÉâ**
                async function tryPriority4_LoadingTrigger() {
                    logs.push('üéØ [4ÏàúÏúÑ] Î°úÎî© Ìä∏Î¶¨Í±∞ ÌõÑ Ïû¨ÌÉêÏÉâ ÏãúÎèÑ');
                    
                    // ÎçîÎ≥¥Í∏∞ Î≤ÑÌäº Ï∞æÍ∏∞
                    const loadMoreButtons = document.querySelectorAll(
                        '[data-testid*="load"], [class*="load"], [class*="more"], ' +
                        'button[class*="more"], .load-more, .show-more, ' +
                        '[aria-label*="more"], [aria-label*="load"]'
                    );
                    
                    if (loadMoreButtons.length > 0) {
                        logs.push('ÎçîÎ≥¥Í∏∞ Î≤ÑÌäº Î∞úÍ≤¨: ' + loadMoreButtons.length + 'Í∞ú');
                        
                        // Î≤ÑÌäº ÌÅ¥Î¶≠
                        let clicked = 0;
                        for (let i = 0; i < Math.min(3, loadMoreButtons.length); i++) {
                            const btn = loadMoreButtons[i];
                            if (btn && typeof btn.click === 'function') {
                                btn.click();
                                clicked++;
                            }
                        }
                        
                        if (clicked > 0) {
                            logs.push('ÎçîÎ≥¥Í∏∞ Î≤ÑÌäº ÌÅ¥Î¶≠: ' + clicked + 'Í∞ú');
                            
                            // Î†åÎçîÎßÅ ÏïàÏ†ï ÎåÄÍ∏∞
                            await waitForStableLayout({ frames: 4, timeout: 1500 });
                            await waitForDOMStable({ timeout: 800, stableTime: 200 });
                            
                            logs.push('Î†åÎçîÎßÅ ÏïàÏ†ï ÎåÄÍ∏∞ ÏôÑÎ£å');
                            
                            // Ïû¨ÌÉêÏÉâ: 2ÏàúÏúÑ, 3ÏàúÏúÑ Ïû¨ÏãúÎèÑ
                            const retry2 = await tryPriority2_StableAttributes();
                            if (retry2.success) {
                                logs.push('‚úÖ [4ÏàúÏúÑ] ÏÑ±Í≥µ: Î°úÎî© ÌõÑ 2ÏàúÏúÑ Ïû¨ÌÉêÏÉâ');
                                return {
                                    success: true,
                                    method: 'priority4_loading_retry2',
                                    result: retry2.result
                                };
                            }
                            
                            const retry3 = await tryPriority3_StructuralRole();
                            if (retry3.success) {
                                logs.push('‚úÖ [4ÏàúÏúÑ] ÏÑ±Í≥µ: Î°úÎî© ÌõÑ 3ÏàúÏúÑ Ïû¨ÌÉêÏÉâ');
                                return {
                                    success: true,
                                    method: 'priority4_loading_retry3',
                                    result: retry3.result
                                };
                            }
                        }
                    }
                    
                    logs.push('‚ùå [4ÏàúÏúÑ] Ïã§Ìå®: Î°úÎî© Ìä∏Î¶¨Í±∞ ÌõÑÏóêÎèÑ Îß§Ïπ≠ ÏóÜÏùå');
                    return { success: false };
                }
                
                // üéØ **5ÏàúÏúÑ: ÏÉÅÎåÄÏ¢åÌëú ÌíÄÎ∞±**
                async function tryPriority5_RelativePosition() {
                    logs.push('üéØ [5ÏàúÏúÑ] ÏÉÅÎåÄÏ¢åÌëú ÌíÄÎ∞± ÏãúÎèÑ');
                    
                    // Î†åÎçîÎßÅ ÏïàÏ†ï ÎåÄÍ∏∞
                    await waitForStableLayout({ frames: 3, timeout: 1000 });
                    
                    const ROOT = getROOT();
                    const max = getMaxScroll();
                    
                    // Î∞±Î∂ÑÏú® Í∏∞Î∞ò Î≥µÏõê
                    const calcX = (targetPercentX / 100) * max.x;
                    const calcY = (targetPercentY / 100) * max.y;
                    
                    logs.push('Î∞±Î∂ÑÏú® Í≥ÑÏÇ∞: X=' + calcX.toFixed(1) + 'px, Y=' + calcY.toFixed(1) + 'px');
                    
                    const result = preciseScrollTo(calcX, calcY);
                    
                    logs.push('‚úÖ [5ÏàúÏúÑ] ÏÉÅÎåÄÏ¢åÌëú ÌíÄÎ∞± Ï†ÅÏö©');
                    
                    return {
                        success: true,
                        method: 'priority5_relative_position',
                        result: result
                    };
                }
                
                // üéØ **Î©îÏù∏ Ïã§Ìñâ Î°úÏßÅ**
                let finalResult = null;
                
                // 1ÏàúÏúÑ ÏãúÎèÑ
                finalResult = await tryPriority1_IdHash();
                if (finalResult.success) {
                    const diffX = Math.abs(finalResult.result.x - targetX);
                    const diffY = Math.abs(finalResult.result.y - targetY);
                    
                    // üì® MessageHandlerÎ°ú Í≤∞Í≥º Ï†ÑÏÜ°
                    window.webkit.messageHandlers.bfcacheRestoreResult.postMessage({
                        success: true,
                        method: finalResult.method,
                        finalPosition: { x: finalResult.result.x, y: finalResult.result.y },
                        difference: { x: diffX, y: diffY },
                        headerAdjustment: finalResult.result.headerAdjustment || 0,
                        logs: logs
                    });
                    return;
                }
                
                // 2ÏàúÏúÑ ÏãúÎèÑ
                finalResult = await tryPriority2_StableAttributes();
                if (finalResult.success) {
                    const diffX = Math.abs(finalResult.result.x - targetX);
                    const diffY = Math.abs(finalResult.result.y - targetY);
                    
                    window.webkit.messageHandlers.bfcacheRestoreResult.postMessage({
                        success: true,
                        method: finalResult.method,
                        finalPosition: { x: finalResult.result.x, y: finalResult.result.y },
                        difference: { x: diffX, y: diffY },
                        headerAdjustment: finalResult.result.headerAdjustment || 0,
                        logs: logs
                    });
                    return;
                }
                
                // 3ÏàúÏúÑ ÏãúÎèÑ
                finalResult = await tryPriority3_StructuralRole();
                if (finalResult.success) {
                    const diffX = Math.abs(finalResult.result.x - targetX);
                    const diffY = Math.abs(finalResult.result.y - targetY);
                    
                    window.webkit.messageHandlers.bfcacheRestoreResult.postMessage({
                        success: true,
                        method: finalResult.method,
                        finalPosition: { x: finalResult.result.x, y: finalResult.result.y },
                        difference: { x: diffX, y: diffY },
                        headerAdjustment: finalResult.result.headerAdjustment || 0,
                        logs: logs
                    });
                    return;
                }
                
                // 4ÏàúÏúÑ ÏãúÎèÑ
                finalResult = await tryPriority4_LoadingTrigger();
                if (finalResult.success) {
                    const diffX = Math.abs(finalResult.result.x - targetX);
                    const diffY = Math.abs(finalResult.result.y - targetY);
                    
                    window.webkit.messageHandlers.bfcacheRestoreResult.postMessage({
                        success: true,
                        method: finalResult.method,
                        finalPosition: { x: finalResult.result.x, y: finalResult.result.y },
                        difference: { x: diffX, y: diffY },
                        headerAdjustment: finalResult.result.headerAdjustment || 0,
                        logs: logs
                    });
                    return;
                }
                
                // 5ÏàúÏúÑ ÏãúÎèÑ (ÏµúÏ¢Ö ÌíÄÎ∞±)
                finalResult = await tryPriority5_RelativePosition();
                const diffX = Math.abs(finalResult.result.x - targetX);
                const diffY = Math.abs(finalResult.result.y - targetY);
                
                window.webkit.messageHandlers.bfcacheRestoreResult.postMessage({
                    success: diffY <= 50, // 50px ÌóàÏö© Ïò§Ï∞®
                    method: finalResult.method,
                    finalPosition: { x: finalResult.result.x, y: finalResult.result.y },
                    difference: { x: diffX, y: diffY },
                    headerAdjustment: finalResult.result.headerAdjustment || 0,
                    logs: logs
                });
                
            } catch(e) {
                // ÏóêÎü¨ Î∞úÏÉù ÏãúÏóêÎèÑ MessageHandlerÎ°ú Ï†ÑÏÜ°
                window.webkit.messageHandlers.bfcacheRestoreResult.postMessage({
                    success: false,
                    error: e.message,
                    logs: ['Ïö∞ÏÑ†ÏàúÏúÑ Í∏∞Î∞ò Î≥µÏõê Ïã§Ìå®: ' + e.message]
                });
            }
            })();
            return true;
        })();
        """
    }
    
    // ÏïàÏ†ÑÌïú JSON Î≥ÄÌôò Ïú†Ìã∏Î¶¨Ìã∞
    private func convertToJSONString(_ object: Any) -> String? {
        do {
            let jsonData = try JSONSerialization.data(withJSONObject: object, options: [])
            return String(data: jsonData, encoding: .utf8)
        } catch {
            TabPersistenceManager.debugMessages.append("JSON Î≥ÄÌôò Ïã§Ìå®: \(error.localizedDescription)")
            return nil
        }
    }
}

// MARK: - üì® **BFCache Î≥µÏõê Í≤∞Í≥º MessageHandler**
class BFCacheRestoreMessageHandler: NSObject, WKScriptMessageHandler {
    private let completion: ([String: Any]) -> Void
    
    init(completion: @escaping ([String: Any]) -> Void) {
        self.completion = completion
        super.init()
    }
    
    func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) {
        guard message.name == "bfcacheRestoreResult",
              let result = message.body as? [String: Any] else {
            TabPersistenceManager.debugMessages.append("‚ùå MessageHandler: ÏûòÎ™ªÎêú Î©îÏãúÏßÄ ÌòïÏãù")
            return
        }
        
        DispatchQueue.main.async {
            self.completion(result)
        }
    }
}

// MARK: - BFCacheTransitionSystem Ï∫êÏ≤ò/Î≥µÏõê ÌôïÏû• (Í∏∞Ï°¥ ÏΩîÎìú Ïú†ÏßÄ)
extension BFCacheTransitionSystem {
    
    // MARK: - üîß **ÌïµÏã¨ Í∞úÏÑ†: ÏõêÏûêÏ†Å Ï∫°Ï≤ò ÏûëÏóÖ**
    
    private struct CaptureTask {
        let pageRecord: PageRecord
        let tabID: UUID?
        let type: CaptureType
        weak var webView: WKWebView?
        let requestedAt: Date = Date()
    }
    
    func captureSnapshot(pageRecord: PageRecord, webView: WKWebView?, type: CaptureType = .immediate, tabID: UUID? = nil) {
        guard let webView = webView else {
            TabPersistenceManager.debugMessages.append("‚ùå Ï∫°Ï≤ò Ïã§Ìå®: ÏõπÎ∑∞ ÏóÜÏùå - \(pageRecord.title)")
            return
        }
        
        let task = CaptureTask(pageRecord: pageRecord, tabID: tabID, type: type, webView: webView)
        
        TabPersistenceManager.debugMessages.append("üì∏ Ï∫°Ï≤ò ÎåÄÏÉÅ: \(pageRecord.url.host ?? "unknown") - \(pageRecord.title)")
        
        serialQueue.async { [weak self] in
            self?.performAtomicCapture(task)
        }
    }
    
    private func performAtomicCapture(_ task: CaptureTask) {
        let pageID = task.pageRecord.id
        
        guard let webView = task.webView else {
            TabPersistenceManager.debugMessages.append("‚ùå ÏõπÎ∑∞ Ìï¥Ï†úÎê® - Ï∫°Ï≤ò Ï∑®ÏÜå: \(task.pageRecord.title)")
            return
        }
        
        TabPersistenceManager.debugMessages.append("üì∏ ÏßÅÎ†¨ Ï∫°Ï≤ò ÏãúÏûë: \(task.pageRecord.title) (\(task.type))")
        
        let captureData = DispatchQueue.main.sync { () -> CaptureData? in
            guard webView.window != nil, !webView.bounds.isEmpty else {
                TabPersistenceManager.debugMessages.append("‚ö†Ô∏è ÏõπÎ∑∞ Ï§ÄÎπÑ ÏïàÎê® - Ï∫°Ï≤ò Ïä§ÌÇµ: \(task.pageRecord.title)")
                return nil
            }
            
            return CaptureData(
                scrollPosition: webView.scrollView.contentOffset,
                contentSize: webView.scrollView.contentSize,
                viewportSize: webView.bounds.size,
                actualScrollableSize: CGSize(
                    width: max(webView.scrollView.contentSize.width, webView.scrollView.bounds.width),
                    height: max(webView.scrollView.contentSize.height, webView.scrollView.bounds.height)
                ),
                bounds: webView.bounds,
                isLoading: webView.isLoading
            )
        }
        
        guard let data = captureData else {
            return
        }
        
        let captureResult = performRobustCapture(
            pageRecord: task.pageRecord,
            webView: webView,
            captureData: data,
            retryCount: task.type == .immediate ? 2 : 0
        )
        
        if let tabID = task.tabID {
            saveToDisk(snapshot: captureResult, tabID: tabID)
        } else {
            storeInMemory(captureResult.snapshot, for: pageID)
        }
        
        TabPersistenceManager.debugMessages.append("‚úÖ ÏßÅÎ†¨ Ï∫°Ï≤ò ÏôÑÎ£å: \(task.pageRecord.title)")
    }
    
    private struct CaptureData {
        let scrollPosition: CGPoint
        let contentSize: CGSize
        let viewportSize: CGSize
        let actualScrollableSize: CGSize
        let bounds: CGRect
        let isLoading: Bool
    }
    
    private func performRobustCapture(pageRecord: PageRecord, webView: WKWebView, captureData: CaptureData, retryCount: Int = 0) -> (snapshot: BFCacheSnapshot, image: UIImage?) {
        
        for attempt in 0...retryCount {
            let result = attemptCapture(pageRecord: pageRecord, webView: webView, captureData: captureData)
            
            if result.snapshot.captureStatus != .failed || attempt == retryCount {
                if attempt > 0 {
                    TabPersistenceManager.debugMessages.append("üîÑ Ïû¨ÏãúÎèÑ ÌõÑ Ï∫êÏ≤ò ÏÑ±Í≥µ: \(pageRecord.title) (ÏãúÎèÑ: \(attempt + 1))")
                }
                return result
            }
            
            TabPersistenceManager.debugMessages.append("‚è≥ Ï∫°Ï≤ò Ïã§Ìå® - Ïû¨ÏãúÎèÑ (\(attempt + 1)/\(retryCount + 1)): \(pageRecord.title)")
            Thread.sleep(forTimeInterval: 0.08)
        }
        
        return (BFCacheSnapshot(pageRecord: pageRecord, scrollPosition: captureData.scrollPosition, actualScrollableSize: captureData.actualScrollableSize, timestamp: Date(), captureStatus: .failed, version: 1), nil)
    }
    
    private func attemptCapture(pageRecord: PageRecord, webView: WKWebView, captureData: CaptureData) -> (snapshot: BFCacheSnapshot, image: UIImage?) {
        var visualSnapshot: UIImage? = nil
        var domSnapshot: String? = nil
        var jsState: [String: Any]? = nil
        let semaphore = DispatchSemaphore(value: 0)
        
        TabPersistenceManager.debugMessages.append("üì∏ Ïä§ÎÉÖÏÉ∑ Ï∫°Ï≤ò ÏãúÎèÑ: \(pageRecord.title)")
        
        // 1. ÎπÑÏ£ºÏñº Ïä§ÎÉÖÏÉ∑
        DispatchQueue.main.sync {
            let config = WKSnapshotConfiguration()
            config.rect = captureData.bounds
            config.afterScreenUpdates = false
            
            webView.takeSnapshot(with: config) { image, error in
                if let error = error {
                    TabPersistenceManager.debugMessages.append("üì∏ Ïä§ÎÉÖÏÉ∑ Ïã§Ìå®, fallback ÏÇ¨Ïö©: \(error.localizedDescription)")
                    visualSnapshot = self.renderWebViewToImage(webView)
                } else {
                    visualSnapshot = image
                    TabPersistenceManager.debugMessages.append("üì∏ Ïä§ÎÉÖÏÉ∑ ÏÑ±Í≥µ")
                }
                semaphore.signal()
            }
        }
        
        let result = semaphore.wait(timeout: .now() + 3.0)
        if result == .timedOut {
            TabPersistenceManager.debugMessages.append("‚è∞ Ïä§ÎÉÖÏÉ∑ Ï∫°Ï≤ò ÌÉÄÏûÑÏïÑÏõÉ: \(pageRecord.title)")
            visualSnapshot = renderWebViewToImage(webView)
        }
        
        // 2. DOM Ï∫°Ï≤ò
        let domSemaphore = DispatchSemaphore(value: 0)
        TabPersistenceManager.debugMessages.append("üåê DOM Ï∫°Ï≤ò ÏãúÏûë")
        
        DispatchQueue.main.sync {
            let domScript = """
            (function() {
                try {
                    if (document.readyState !== 'complete') return null;
                    
                    document.querySelectorAll('[class*="active"], [class*="pressed"], [class*="hover"], [class*="focus"]').forEach(function(el) {
                        var classList = Array.from(el.classList);
                        var classesToRemove = classList.filter(function(c) {
                            return c.includes('active') || c.includes('pressed') || c.includes('hover') || c.includes('focus');
                        });
                        for (var i = 0; i < classesToRemove.length; i++) {
                            el.classList.remove(classesToRemove[i]);
                        }
                    });
                    
                    document.querySelectorAll('input:focus, textarea:focus, select:focus, button:focus').forEach(function(el) {
                        el.blur();
                    });
                    
                    var html = document.documentElement.outerHTML;
                    return html.length > 500000 ? html.substring(0, 500000) : html;
                } catch(e) { return null; }
            })()
            """
            
            webView.evaluateJavaScript(domScript) { result, error in
                if let error = error {
                    TabPersistenceManager.debugMessages.append("üåê DOM Ï∫°Ï≤ò Ïã§Ìå®: \(error.localizedDescription)")
                } else if let dom = result as? String {
                    domSnapshot = dom
                    TabPersistenceManager.debugMessages.append("üåê DOM Ï∫°Ï≤ò ÏÑ±Í≥µ: \(dom.count)Î¨∏Ïûê")
                }
                domSemaphore.signal()
            }
        }
        _ = domSemaphore.wait(timeout: .now() + 5.0)
        
        // 3. JS ÏÉÅÌÉú Ï∫°Ï≤ò
        let jsSemaphore = DispatchSemaphore(value: 0)
        TabPersistenceManager.debugMessages.append("üî• JS ÏÉÅÌÉú Ï∫°Ï≤ò ÏãúÏûë")
        
        DispatchQueue.main.sync {
            let jsScript = generateAnchorCaptureScript()
            
            webView.evaluateJavaScript(jsScript) { result, error in
                if let error = error {
                    TabPersistenceManager.debugMessages.append("üî• JS ÏÉÅÌÉú Ï∫°Ï≤ò Ïò§Î•ò: \(error.localizedDescription)")
                } else if let data = result as? [String: Any] {
                    jsState = data
                    TabPersistenceManager.debugMessages.append("‚úÖ JS ÏÉÅÌÉú Ï∫°Ï≤ò ÏÑ±Í≥µ: \(Array(data.keys))")
                } else {
                    TabPersistenceManager.debugMessages.append("üî• JS ÏÉÅÌÉú Ï∫°Ï≤ò Í≤∞Í≥º ÌÉÄÏûÖ Ïò§Î•ò: \(type(of: result))")
                }
                jsSemaphore.signal()
            }
        }
        _ = jsSemaphore.wait(timeout: .now() + 3.0)
        
        // Ï∫°Ï≤ò ÏÉÅÌÉú Í≤∞Ï†ï
        let captureStatus: BFCacheSnapshot.CaptureStatus
        if visualSnapshot != nil && domSnapshot != nil && jsState != nil {
            captureStatus = .complete
            TabPersistenceManager.debugMessages.append("‚úÖ ÏôÑÏ†Ñ Ï∫°Ï≤ò ÏÑ±Í≥µ")
        } else if visualSnapshot != nil {
            captureStatus = jsState != nil ? .partial : .visualOnly
            TabPersistenceManager.debugMessages.append("‚ö° Î∂ÄÎ∂Ñ Ï∫°Ï≤ò ÏÑ±Í≥µ: visual=\(visualSnapshot != nil), dom=\(domSnapshot != nil), js=\(jsState != nil)")
        } else {
            captureStatus = .failed
            TabPersistenceManager.debugMessages.append("‚ùå Ï∫°Ï≤ò Ïã§Ìå®")
        }
        
        // Î≤ÑÏ†Ñ Ï¶ùÍ∞Ä
        let version: Int = cacheAccessQueue.sync(flags: .barrier) { [weak self] in
            guard let self = self else { return 1 }
            let currentVersion = self._cacheVersion[pageRecord.id] ?? 0
            let newVersion = currentVersion + 1
            self._cacheVersion[pageRecord.id] = newVersion
            return newVersion
        }
        
        let scrollPercent: CGPoint
        if captureData.actualScrollableSize.height > captureData.viewportSize.height || captureData.actualScrollableSize.width > captureData.viewportSize.width {
            let maxScrollX = max(0, captureData.actualScrollableSize.width - captureData.viewportSize.width)
            let maxScrollY = max(0, captureData.actualScrollableSize.height - captureData.viewportSize.height)
            
            scrollPercent = CGPoint(
                x: maxScrollX > 0 ? (captureData.scrollPosition.x / maxScrollX * 100.0) : 0,
                y: maxScrollY > 0 ? (captureData.scrollPosition.y / maxScrollY * 100.0) : 0
            )
        } else {
            scrollPercent = CGPoint.zero
        }
        
        TabPersistenceManager.debugMessages.append("üìä Ï∫°Ï≤ò ÏôÑÎ£å: ÏúÑÏπò=(\(String(format: "%.1f", captureData.scrollPosition.x)), \(String(format: "%.1f", captureData.scrollPosition.y))), Î∞±Î∂ÑÏú®=(\(String(format: "%.2f", scrollPercent.x))%, \(String(format: "%.2f", scrollPercent.y))%)")
        
        let snapshot = BFCacheSnapshot(
            pageRecord: pageRecord,
            domSnapshot: domSnapshot,
            scrollPosition: captureData.scrollPosition,
            scrollPositionPercent: scrollPercent,
            contentSize: captureData.contentSize,
            viewportSize: captureData.viewportSize,
            actualScrollableSize: captureData.actualScrollableSize,
            jsState: jsState,
            timestamp: Date(),
            webViewSnapshotPath: nil,
            captureStatus: captureStatus,
            version: version
        )
        
        return (snapshot, visualSnapshot)
    }
    
    // üî• **ÏïµÏª§ Ï∫°Ï≤ò Ïä§ÌÅ¨Î¶ΩÌä∏**
    private func generateAnchorCaptureScript() -> String {
        return """
        (function() {
            try {
                console.log('üì∏ ÏïµÏª§ Ï∫°Ï≤ò ÏãúÏûë');
                
                function getROOT() { 
                    return document.scrollingElement || document.documentElement; 
                }
                
                const ROOT = getROOT();
                const scrollY = parseFloat(ROOT.scrollTop) || 0;
                const scrollX = parseFloat(ROOT.scrollLeft) || 0;
                const viewportHeight = parseFloat(window.innerHeight) || 0;
                const viewportWidth = parseFloat(window.innerWidth) || 0;
                
                // Î≥¥Ïù¥Îäî ÏòÅÏó≠Ïùò ÏöîÏÜåÎì§Îßå ÏàòÏßë
                const anchors = [];
                const viewportRect = {
                    top: scrollY,
                    left: scrollX,
                    bottom: scrollY + viewportHeight,
                    right: scrollX + viewportWidth
                };
                
                // ÏïàÏ†ïÏ†Å ÏÜçÏÑ±ÏùÑ Í∞ÄÏßÑ ÏöîÏÜåÎì§ Ïö∞ÏÑ† ÏàòÏßë
                const stableSelectors = [
                    '[data-id]', '[data-anchor]', '[data-test-id]', '[itemid]',
                    '[role="listitem"]', '[role="article"]', '[role="main"]',
                    'article', 'section', 'main'
                ];
                
                for (let i = 0; i < stableSelectors.length; i++) {
                    const elements = document.querySelectorAll(stableSelectors[i]);
                    for (let j = 0; j < elements.length && anchors.length < 20; j++) {
                        const el = elements[j];
                        const rect = el.getBoundingClientRect();
                        const elementTop = scrollY + rect.top;
                        
                        // Î∑∞Ìè¨Ìä∏ ÎÇ¥Ïóê ÏûàÎäîÏßÄ ÌôïÏù∏
                        if (elementTop >= viewportRect.top && elementTop <= viewportRect.bottom) {
                            const anchorData = {
                                absolutePosition: { top: elementTop, left: scrollX + rect.left },
                                element: {
                                    tagName: el.tagName,
                                    id: el.id || null,
                                    dataset: {
                                        id: el.dataset.id || null,
                                        anchor: el.dataset.anchor || null,
                                        testId: el.dataset.testId || null
                                    },
                                    role: el.getAttribute('role') || null,
                                    ariaLabelledBy: el.getAttribute('aria-labelledby') || null,
                                    itemId: el.getAttribute('itemid') || null
                                },
                                textContent: (el.textContent || '').trim().substring(0, 100)
                            };
                            anchors.push(anchorData);
                        }
                    }
                }
                
                console.log('üì∏ ÏïµÏª§ Ï∫°Ï≤ò ÏôÑÎ£å:', anchors.length, 'Í∞ú');
                
                return {
                    infiniteScrollAnchors: {
                        anchors: anchors,
                        stats: { totalAnchors: anchors.length }
                    },
                    scroll: { x: scrollX, y: scrollY },
                    href: window.location.href,
                    title: document.title,
                    timestamp: Date.now()
                };
            } catch(e) { 
                console.error('üì∏ ÏïµÏª§ Ï∫°Ï≤ò Ïã§Ìå®:', e);
                return {
                    infiniteScrollAnchors: { anchors: [], stats: {} },
                    scroll: { x: 0, y: 0 },
                    href: window.location.href,
                    error: e.message
                };
            }
        })()
        """
    }
    
    internal func renderWebViewToImage(_ webView: WKWebView) -> UIImage? {
        let renderer = UIGraphicsImageRenderer(bounds: webView.bounds)
        return renderer.image { context in
            webView.layer.render(in: context.cgContext)
        }
    }
    
    // MARK: - üåê JavaScript Ïä§ÌÅ¨Î¶ΩÌä∏
    
    static func makeBFCacheScript() -> WKUserScript {
        let scriptSource = """
        window.addEventListener('pageshow', function(event) {
            if (event.persisted) {
                console.log('üéØ BFCache ÌéòÏù¥ÏßÄ Î≥µÏõê');
            }
        });
        
        window.addEventListener('pagehide', function(event) {
            if (event.persisted) {
                console.log('üì∏ BFCache ÌéòÏù¥ÏßÄ Ï†ÄÏû•');
            }
        });
        
        """
        return WKUserScript(source: scriptSource, injectionTime: .atDocumentStart, forMainFrameOnly: false)
    }
}
